% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/solve_for_hiershrink_scale.R
\name{solve_for_hiershrink_scale}
\alias{solve_for_hiershrink_scale}
\title{Numerical-based solution to the scale parameter}
\usage{
solve_for_hiershrink_scale(
  target_mean,
  npar,
  local_dof = 1,
  global_dof = 1,
  slab_precision = (1/15)^2,
  n,
  tol = .Machine$double.eps^0.5,
  max_iter = 100,
  n_sim = 2e+05
)
}
\arguments{
\item{target_mean}{(pos. reals): the desired prior number of effective parameters
(tilde xi_eff in Boonstra and Barbaro). An error will be thrown if target_mean > npar}

\item{npar}{(pos. integers): the number of covariates.}

\item{local_dof}{(pos. integer) number indicating the degrees of freedom for
lambda_j. Boonstra and Barbaro always used local_dof = 1. Choose a negative
value to tell the function that there are no local hyperparameters.}

\item{global_dof}{(pos. integer) number indicating the degrees of freedom for
tau. Boonstra and Barbaro always used global_dof = 1. Choose a negative
value to tell the function that there is no global hyperparameter.}

\item{slab_precision}{(pos. real) the slab-part of the regularized horseshoe,
this is equivalent to (1/d)^2 in the notation of Boonstra and Barbaro}

\item{n}{(pos. integer) sample size of the study}

\item{tol}{(pos. real) numerical tolerance for convergence of solution}

\item{max_iter}{(pos. integer) maximum number of iterations to run without
convergence before giving up}

\item{n_sim}{(pos. integer) number of simulated draws from the underlying student-t
hyperpriors to calculate the Monte Carlo-based approximation of the expectation.}
}
\value{
A \code{list} containing the following named elements:
\itemize{
  \item{scale1}{the solution, interpreted as c / sigma}
  \item{diff_from_target1}{the difference between the numerical value and the target, should be close to zero}
  \item{iter1}{number of iterations performed}
  \item{prior_num1}{the resulting value of m_eff corresponding to this solution}
}
}
\description{
This function calculates a numerical-based solution to the quantity c / sigma in
the equation at the end of first paragraph on page e50. It is intended to
be provided as the value for beta_orig_scale and beta_aug_scale in the functions
`glm_sab`, `glm_nab`, and `glm_standard`
}
\details{
If the outcome of interest is binary, then sigma doesn't actually exist as a real
parameter, and it will be set equal to 2 inside `glm_sab`,  `glm_nab`, or `glm_standard`.
If the outcome of interest is continuous, then sigma is equipped with its own weak
prior. In either case, it is not intended that the user scale by sigma "manually".
}
